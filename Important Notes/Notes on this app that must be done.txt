2023/05 Course Started

WE WANT TO SAVE OUR PROGRESS TO VERSION CONTROL OR SOURCE CONTROL:
-Install Github and git bash
-Make sure you have a github account
-Go to profile->Settings->Developer Settings->Personal access token->Tokens Classic->Generate new token->Generate new token (classic)->Give it a note or name->No expiration->Check all the boxes->Generate Token->Copy the token and save it somewhere and use the token for your password, because of pushing and comitting code to my github repo
-This is mey generated token: Use the following token/password when comitting things to my personal github: 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
-Go to the project and open up git bash or any terminal or my choice:
-Type git status -> It will say "not a git repo"
-Go to github and create a new repository
-Follow all the steps to commit and push on github
-Create a .gitignore file-> Watch a vido on youtube how to create on visual studio
-Go back to see the changes, you'll see that the changes are less now
-We also dont want the appsettings.json file to be included in the commits so right click and add to .gitignore file

MAKE THE FRONTEND RUN ON HTTPS INSTEAD OF JUST SO IT AN BE THE SAME AS THE BACKEND RUNNING ON HTTPS
-Go to the studentassets folder->generateTrustedSSL
-Click on server and do all the steps.
-Create a ssl folder in the client app
-Copy the server and server.ky files and paste it in the ssl folder from the generateTrustedSSL folder
-Go to angular.json file and under serve add the following object-> "options":{
            "sslCert": "./ssl/server.crt",
            "sslKey": "./ssl/server.key",
            "ssl": true
          },
-Restart the application and rerun ng serve -o
-Go to the lock next to the url and check the certicate

WHEN CREATING SERVICES IN THE API IT'S IMPORTANT TO CREATE INTERFACES AND IMPLEMENTATION/SERVICE CLASS AT THE SAME TIME AND DEFINE THEM ASS BUILDER.SERVICE.ADDSCOPE(...) in the program.cs class - Section 4 video 41.

SECTION 6 ROUTING IN ANGULAR:::::::
TO ENSURE THAT ONLY AUTHORISED USERS CAN ACCESS A SPECIFIC ENDPOINT:
-Do it on top of the http request in a controllers method eg. [Authorize] and you can also add [AllowAnonymous], but not at the beginning of the controller

IF WE WANT SOME OF THE LINKS TO BE PROTECTED THAT A NON LOGGED INUSER SHOULDNT ACCESS:
-We should consider using AuthGuard.ts which is an extra file that should be created to see if theres already a user that exists in that observable we created.
-Go to app-routing.module.ts file and add the canActivate property to one of the paths in your Routes array.
-Angular or the client side can never give us security its only the api that can code security. The Client only hides stuff for us

FOR ANY THIRD PARTIES IMPORTS IN ANGULAR APPLICATION
-Use an extra module besides app.module.ts that is shared.module.ts
-If we want the imports to work in the shared.module.ts we also need to export them, creating an export array the same as the imports array

SECTION 7 ERROR HANDLING:::::::
WHEN ADDING ERROR HANDLING IN YOUR APPLICATION, IT IS A MUST
=BACKEND
-Start with a BuggyController - Create all methods for different errors. Test them on postman or swagger if they do have the methods in the controller
-With this controller we will get way too much information when an error occur, eg. lines of errors, but we are interested only in something short
-When we're in development mode in the launchSettings.json file and this means we will see a lot of errors, but with production mode you wont be able to see much errors
-To go back to the second step we are done with all the methods in the controller, but if we see an exception that might occur in our code we want to add a try catch block. Now adding a try and catch block to each method in the buggyController. Its better to handle exceptions at the highest level instead of writing try catch for each method in the BuggyController. So we're not taking that approach(try cartch), we leave the methods as is!
-Now create our own middleware to handle exceptions in our application
-Create new folder errors in the api folder
-Create new class ApiException.cs inside the errors folder: This is gonna contain the response of what we are gonna be sending back to the client when we have an exception. Check the file for details.
-Inside the api create a new folder called Middleware.
-Another c# class called ExceptionMiddleware.cs inside the Middleware folder to handle exceptions in out application. Read the details of how things are done in the file
-Now since we're done in ExceptionMiddleware.cs class and in order to use this middleware now we need to go back to our program.cs class
-Exception handling has to go to the very top of the HTTP request pipeline in this program.cs file
-Done. Run the application and test in swagger or postman
=CLIENT
-We gonna do something similar in the angular side, we gonna create a component that we going to use to test our different error responses we getting back from the server. Just to manage and handle errors on the client side
-Create component errors/test-error and follow the details
-Add that error component top the app-routing.module.ts file 
-Add then to the nav so that it can be accessed
-Create an interceptor called interceptors/error and follow the details in the file for the errors that we can get in the application in the client.
-Add the interceptor in the providers array in app.module.ts
- So we want to make use of validation errors in the client, but on the test 400 Validation Error button we get an error that contains 2 arrays and we need to make it one array with a few indexes.
-So when it comes to validation errors, users are typically gonna fill out a form and we want to display on that form somewhere what they have done wrong when they completed a field incorrectly.
-Go to the test-error component and test if I can run ngFor over that array of the errors and create a new array to have those errors
-Create 2 new components in the errors folder that will navigate to another component when reaching error 404(not-found) and error 500(server-error)
-Add the Handling Not found
-Adding the server-error page

IF WE SEE SOMETHING IN OUR CODE THAT CAN POTENTIALLY THROW AN EXCEPTION THEN USE A TRY CATCH!

Section 8: Extending the API
-Generating seed data: In order to populate the Database with data instead of making it time consuming use the "json generator" in the browser
-Create a # class in the Data folder and call it Seed and follow the code in there.
-In order to apply the seed data: Up till now we have been using the Package Manager console and ran migrations and update the database, but we can also do that in code and not only package manager console
-A good place to do this i when the application starts up and this is in the Program.cs class which is the entry point of the applicataion
-Start Coding the program.cs class and follow thhe seeding data part one video. The implementation for the migration on Seeding data must go after the MapControllers() and before the Run()

CREATING A REPOSITORY PATTERN AND MOVING AWAY FROM DBCONTEXT
-DbContext supports the following methods:
	-Users.First()
	-Users.FirstOrDefault()
	-Users.SingleOrDefault()
	-Users.Include(x=>x.Thing).FirstOrDefault
	-+10000 other methods
-Repository supports the following methods:
	-GetUser()
	-GetUsers()
	-UpdateUser()
	-SaveAll()
-DataContext in the controller will make it more difficult to test the controllers, because we need an implementation of the DataContext class in order to test the controllers
-The DataContext class is Big and Complex and we want to avoid having to have an implementation of the DataContext.
-In order to implement the Repository pattern we need to have an Interface and an implementation for our new Repository
-Creating interfaces will be in the Interface folder
-Creating the Implementation class will be in the Data Folder
-Now that Im done with the Interface and implementation class, I need to add this to the ApplicationServiceExtension class and add it as another service under the other services as AddScoped inside the static class.
-Now Change the Users Controller accordingly to get rid of the DataContext implementation and implement the Interface and Implementation class
-We are actually returning an AppUser and Poto, but we dont want to return all the properties, we just want to return a few properties from AppUser and Photo.
-Theres a relationship between the AppUser and the Photo. One(AppUser) To Many(Photo) relationship. Since we dont want the entire AppUser model and Photo Model to be returned, we need to shape our data and in order to do this we need to consider Dto's.
-So we will create 2 Dto's. One for the AppUser Model and one for the Photos Model
-Creating a MemberDto and PhotoDto based on exactly what we want to return.
-So now we need a way to tell our Api instead of returning from our UsersController what we get from the Repository, we need to map the properties from our AppUser into our MemberDto and for Photo into our PhotoDto.
-Creating this code can be extremely tedious and we gonna take a look at a tool that can help us do that called AutoMapper
-So we gonna use the AutoMapper tool to help us map from an Entity to a Dto and later on vice versa
-Go to Nuget Package Manager and search for "AutoMapper" and install "AutoMapper.Extensions.Microsoft.DependencyInjection"
-We gonna use that to inject AutoMapper into our controllers or Repositories as in when we need it.
-After AutoMapper has been installed, Create a new folder called "Helpers"
-Create a new c# class inside that folder an call it "AutoMapperProfiles" and that class derives from "Profile". Now follow the code.
-Make sure to add the AutoMapperProfiles class to the ApplicationServiceExtension Class as another service
-Once we're done with the AutoMapperProfiles Class we need to Inject this as another service into our controller as IMapper from AutoMapper. Do the necessary coding. 
-We will also want to add another photoUrl to the MemberDto, but cant really Map to it, so what we need to do is configure the AutoMapper sectin 8: 96. Look at the notes on the code

SECTION 9:
-Creating an interface in the frontend must be exactly the same as in the result we're getting in the backend in Postman or Swagger
-Never have hardcoded urls in the services files.
-Go to the environments folder and this is where we put in environment variables.
-If we run ur application in production mode, we gonna use environment.prod.ts file and if we're not then we in environment.ts file(Its for Development). Put in the ApiUrl in this file

SECTION 10:
-Adding a Can Deactivate route guard to ask the user do they really want to go to another page if they have unsaved changes. In order to do that we need to consider 
prevent-unsaved-changes.guard.ts file in the Guards folder and specify th component there. And add the Deactive to the path in the routing module next to the component we using to make changes to on the form
-Say for instance we are on the system and then immediatly use the link and type something in like youtube or google and then if we go back we would see we're back in the project where we left off. We dont want that because the user is not notified that the changes will be lost. In order to prevent this we need to get access to the browserEvent and in order to accomplish this we need to consider host listener. The host is the browser in this case and the listener is the events happening on the host which is the browser in this case. Add the hostlistener to the component we are making changes to in the form and add the browser event which is "window:beforeunload"
-Adding loading indicators to the application so that the user can see something they have done is in process. We are using ngx spinner for the loading indicators. The sitewe getting the spinner from: https://github.com/Napster2210/ngx-spinner. When adding the spinner, please use the command: "npm install ngx-spinner --save", by making use of npm.
-Follow the document with regards to the implementation of the spinner. We will also have to create a service that enables the spinner if a http request is going on and stops it when a http request is finished. Created a busy.service.ts file.
- We then also need to create an interceptor file for the loadingin indicator service. And follow the steps inside and make sure to add it to the providers array in the app.module.ts file
-The ngx-spinner component is gonna be visible from anywhere in our application and then open app component since this is our root component. Add the ngx-spinner component to the app component html fiile.
-"Using the Service to store state" / Members List. We've got a small issue when we go into a page it will load since we requesting a service, but if we go to another page and go back to the page we requested an http for, it loads again which meeans its wrong since the application must remember that weve already made a request to that service. We need to access it without the loading indicator again. And also since we get all the matches which means all the members data we dont want the loading indicator to happen when going into a members detail since we already have the data when the member card shows in the matches tab. A note to remeber once the coponent id destroyed the services are not, eg. Once the membersList component is destroyed then goodbye members and then we need to call the services again or reload the members again. So instead of storing our members in the memberslist component only, we must also store our members in the members service for the loading indicator not to load the entire time when we move away from the memberslist component and come back again. The services files does not get destroyed when the users move to different parts of the application and that means we need to add coding to our members service file in the getMembers() method. Please see coding doen in the membersServices file.
-"Using the Service to store state" / Member only. Do exactly the same for getMember() so that when we go into the member details we dont have to load again and again.
-"Using the Service to store state" / Update Member. Do exactly the same for updateMember()
-So nothing will reload anymore because we have our members in memory base on all memebers, get member and update member








